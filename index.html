<html>
    <head>
        <title>PCLP1 2023 Cerinta Tema 1</title>
    </head>

    <body>
        <div class="left_page">
          
            <h1 class="sectionedit1" id="tema_1_-_image_processor">Tema 1 - Image processor</h1>
            <div class="level1">
            
            </div>
            
            <h3 class="sectionedit2" id="changelog">Changelog:</h3>
            <div class="level3">
            <ul>
            <li class="level1"><div class="li"> 13 Dec 2023: deadline-ul a fost amanat pentru data de 17 soft si 20 hard</div>
            </li>
            <li class="level1"><div class="li"> 12 Dec 2023: update checker - toate imagininile sunt acum semnificativ mai mici</div>
            </li>
            <li class="level1"><div class="li"> 30 Nov 2023: update checker sa foloseasca pentru Valgrind inputurile 3-12 in loc de 5-14 pentru ca erau imagini prea mari</div>
            </li>
            <li class="level1"><div class="li"> 28 Nov 2023: update schelet ca sa nu dea mai dea erori de cpplint pe bmp.h si imageprocessing.h</div>
            </li>
            </ul>
            
            </div>
            
            <h3 class="sectionedit3" id="responsabili">Responsabili:</h3>
            <div class="level3">
            <ul>
            <li class="level1"><div class="li"> Alin Popa</div>
            </li>
            </ul>
            
            <p>
            Termen de predare:
            </p>
            <ul>
            <li class="level1"><div class="li"> Deadline soft: <strong>Duminica 17 Decembrie 2023, 23:55</strong></div>
            </li>
            <li class="level1"><div class="li"> Deadline hard: <strong>Miercuri 20 Decembrie 2023, 23:55</strong></div>
            </li>
            </ul>
            
            <p>
            Pentru fiecare zi (24 de ore) de întârziere, se vor scădea 10 puncte din nota acordată, până la atingerea deadline-ului hard.
            </p>
            
            </div>
            
            <h3 class="sectionedit4" id="intrebari">Întrebări</h3>
            <div class="level3">
            
            <p>
            Dacă aveți nelămuriri, puteți să ne contactați pe forumul dedicat <a href="https://curs.upb.ro/2023/mod/forum/view.php?id=80135" class="urlextern" title="https://curs.upb.ro/2023/mod/forum/view.php?id=80135"  rel="nofollow">temei de casă nr. 1</a> sau pe <a href="https://teams.microsoft.com/l/channel/19%3a0a648c85e9ed4a2bbb343b5792443551%40thread.tacv2/Tema%25200?groupId=1f7c7112-0ea2-4f0b-9131-d5c29590d62c&amp;tenantId=2d8cc8ba-8dda-4334-9e5c-fac2092e9bac" class="urlextern" title="https://teams.microsoft.com/l/channel/19%3a0a648c85e9ed4a2bbb343b5792443551%40thread.tacv2/Tema%25200?groupId=1f7c7112-0ea2-4f0b-9131-d5c29590d62c&amp;tenantId=2d8cc8ba-8dda-4334-9e5c-fac2092e9bac"  rel="nofollow">canalul Temei 1</a>.<br/>
            
            La orice întrebare vom răspunde în maxim 24 de ore.<br/>
            
            Nu se acceptă întrebări în ultimele 24 de ore înainte de deadline.
            </p>
            
            <p>
            <p><div class="notewarning">
            Atenție:
            </p>
            <ul>
            <li class="level1"><div class="li"> Citiți cu atenție tot enunțul temei.</div>
            </li>
            </ul>
            
            <p>
            
            </div></p>
            </p>
            
            </div>
            
            <h2 class="sectionedit5" id="intro_imagini">Intro imagini</h2>
            <div class="level2">
            
            <p>
            La această temă ne propunem să construim un program de procesare de imagini. Vom reprezenta o imagine sub forma unei matrici de pixeli NxM (N linii, M coloane), unde pentru fiecare pixel avem 3 valori: R (Red), G (Green), B (Blue) reprezentând cele 3 componente de culoare. Astfel, o imagine va fi o matrice NxMx3 (spre exemplu, <code>m[5][100][0]</code> este componenta Red a pixelului de pe linia 5, coloana 100 din imaginea m). Fiecare din cele 3 componente de culoare poate avea doar valori întregi între 0 și 255 inclusiv. Spre exemplu, un pixel cu valorile <code>(0,0,0)</code> este negru; unul cu valorile <code>(255,255,255)</code> este alb; unul cu valorile <code>(255,255,0)</code> este galben etc.
            </p>
            
            <p>
            Pentru această temă vom considera că o imagine are originea coordonatelor în colțul stânga-sus. De exemplu, rândul 3 reprezintă al treilea rând de pixeli ai imaginii numărat de sus în jos; coloana 3 reprezintă a treia coloană de pixeli numărată de la stânga la dreapta. W (Width) înseamnă dimensiunea imaginii pe orizontală (numărul de coloane); H (Height) înseamnă dimensiunea imaginii pe verticală (numărul de linii). La funcțiile care primesc ca parametru o pereche de coordonate <code>(x,y)</code>, coordonata <code>x</code> este pe orizontală (între 0 și M) iar coordonata <code>y</code> este pe verticală (între 0 și N).
            </p>
            
            <p>
            <p><div class="noteimportant">
            Toate matricile și coordonatele se consideră indexate de la 0 (e.g. coordonata (x=0,y=1) se referă la pixelul de pe prima coloană, a doua linie a imaginii).
            
            </div></p>
            </p>
            
            </div>
            
            <h2 class="sectionedit6" id="schelet_de_cod">Schelet de cod</h2>
            <div class="level2">
            
            <p>
            Pentru această temă trebuie să porniți de la scheletul de cod de aici: <a href="/courses/_media/programare/teme_2023/tema1_schelet.zip" class="media mediafile mf_zip" title="programare:teme_2023:tema1_schelet.zip (1.2 MB)">tema1_schelet.zip</a>.
            </p>
            
            <p>
            În scheletul de cod veți găsi următoarele:
            </p>
            <ul>
            <li class="level1"><div class="li"> Un Makefile cu reguli care compilează și rulează <code>main.c</code> și respectiv <code>interactive.c</code></div>
            </li>
            <li class="level1"><div class="li"> Un fișier <code>imageprocessing.c</code> în care voi va trebui să completați implementările funcțiilor pentru taskurile 1-6</div>
            </li>
            <li class="level1"><div class="li"> Un fișier <code>interactive.c</code> în care voi va trebui să completați implementarea programului pentru taskul 7</div>
            </li>
            <li class="level1"><div class="li"> Un fișier <code>main.c</code> care <strong>nu trebuie trimis în arhiva cu tema</strong>, scopul lui este să vă ofere un exemplu pentru rularea funcțiilor din celelalte fișiere (ca de exemplu, funcțiile <code>read_from_bmp</code> și <code>write_to_bmp</code>).</div>
            </li>
            <li class="level1"><div class="li"> Un fișier <code>bmp.c</code> ce conține implementările funcțiilor <code>read_from_bmp</code> și <code>write_to_bmp</code> ce trebuie folosite în temă.</div>
            </li>
            </ul>
            
            <p>
            <p><div class="noteimportant">
            Atenție! <strong>Nu</strong> aveți voie să:
            </p>
            <ul>
            <li class="level1"><div class="li"> redenumiți fișierele temei (imageprocessing.c și interactive.c)</div>
            </li>
            <li class="level1"><div class="li"> schimbați numărul, tipul, sau ordinea parametrilor funcțiilor din imageprocessing.c și imageprocessing.h</div>
            </li>
            <li class="level1"><div class="li"> schimbați sau redenumiți comenzile sau regulile din Makefile</div>
            </li>
            </ul>
            
            <p>
            
            </div></p>
            </p>
            
            <p>
            <p><div class="noteclassic">
            <strong>Notă referitoare la alocarea dinamică.</strong> Toate funcțiile din fișierul <code>imageprocessing.c</code> primesc ca parametru o imagine care se presupune că a fost deja alocată (dinamic) și returnează imaginea modificată. Dacă aplicați procesările direct pe imaginea primită ca parametru, este suficient să o returnați tot pe ea. Însă dacă alocați o nouă matrice și aplicați procesările pe matricea nou creată, imaginea originală primită ca parametru trebuie dezalocată în aceeași funcție! Atenție: pentru funcțiile de procesare care necesită schimbarea dimensiunii imaginii (e.g. crop, extend), este obligatoriu ca la finalul funcției să obținem o imagine cu exact atâta memorie alocată cât este necesar (e.g. în urma aplicării unui <code>crop</code> de dimensiune 100&times;100 pe o imagine 800&times;600 trebuie să obținem o matrice alocată 100&times;100).
            
            </div></p>
            </p>
            
            </div>
            
            <h2 class="sectionedit7" id="cerinta">Cerință</h2>
            <div class="level2">
            
            </div>
            
            <h3 class="sectionedit8" id="task1_5p_-_flip_horizontal">Task1 (5p) - Flip Horizontal</h3>
            <div class="level3">
            
            <p>
            Implementați în fișierul <code>imageprocessing.c</code> funcția:
            </p>
            <pre class="code">int ***flip_horizontal(int ***image, int N, int M)</pre>
            
            <p>
            Funcția trebuie să returneze imaginea obținută prin oglindirea pe orizontală a imaginii primite ca parametru.
            </p>
            
            <p>
            Exemplu. Dacă imaginea originală avea pixelii:
            $$ A = \begin{bmatrix}
            p_{11} &amp; p_{12} &amp; p_{13} \\
            p_{21} &amp; p_{22} &amp; p_{23} \\
            p_{31} &amp; p_{32} &amp; p_{33}
            \end{bmatrix} $$
            atunci, după oglindire, trebuie să aibă:
            $$ A = \begin{bmatrix}
            p_{13} &amp; p_{12} &amp; p_{11} \\
            p_{23} &amp; p_{22} &amp; p_{21} \\
            p_{33} &amp; p_{32} &amp; p_{31}
            \end{bmatrix} $$
            </p>
            
            </div>
            
            <h3 class="sectionedit9" id="task2_5p_-_rotate_left">Task2 (5p) - Rotate Left</h3>
            <div class="level3">
            
            <p>
            Implementați în fișierul <code>imageprocessing.c</code> funcția:
            </p>
            <pre class="code">int ***rotate_left(int ***image, int N, int M)</pre>
            
            <p>
            Funcția trebuie să returneze imaginea obținută prin rotirea cu 90 de grade la stânga a imaginii primite ca parametru.
            </p>
            
            <p>
            Exemplu. Dacă imaginea originală avea pixelii:
            $$ A = \begin{bmatrix}
            p_{11} &amp; p_{12} &amp; p_{13} \\
            p_{21} &amp; p_{22} &amp; p_{23} \\
            p_{31} &amp; p_{32} &amp; p_{33}
            \end{bmatrix} $$
            atunci, după rotire la stânga, trebuie să aibă:
            $$ A = \begin{bmatrix}
            p_{13} &amp; p_{23} &amp; p_{33} \\
            p_{12} &amp; p_{22} &amp; p_{32} \\
            p_{11} &amp; p_{21} &amp; p_{31}
            \end{bmatrix} $$
            </p>
            
            </div>
            
            <h3 class="sectionedit10" id="task3_5p_-_crop">Task3 (5p) - Crop</h3>
            <div class="level3">
            
            <p>
            Implementați în fișierul <code>imageprocessing.c</code> funcția:
            </p>
            <pre class="code">int ***crop(int ***image, int N, int M, int x, int y, int h, int w)</pre>
            
            <p>
            Funcția trebuie să returneze imaginea obținută prin crop (sub-matrice) care începe (adică colțul stânga-sus al cropului) la coordonatele (x,y), de dimensiune (h,w) (adică sub-matricea rezultată trebuie să aibă h linii, w coloane).
            </p>
            
            <p>
            <p><div class="noteimportant">
            Coordonata x este pe orizontală (denotă coloana) iar coordonata y este pe verticală (denotă linia).
            
            </div></p>
            </p>
            
            <p>
            Exemplu. Dacă imaginea originală avea pixelii:
            $$ A = \begin{bmatrix}
            p_{11} &amp; p_{12} &amp; p_{13} &amp; p_{14} \\
            p_{21} &amp; p_{22} &amp; p_{23} &amp; p_{24} \\
            p_{31} &amp; p_{32} &amp; p_{33} &amp; p_{34}
            \end{bmatrix} $$
            atunci, după aplicarea unui crop cu x=2, y=1, h=2, w=2, trebuie să obținem:
            $$ A = \begin{bmatrix}
            p_{23} &amp; p_{24} \\
            p_{33} &amp; p_{34}
            \end{bmatrix} $$
            </p>
            
            </div>
            
            <h3 class="sectionedit11" id="task4_5p_-_extend">Task4 (5p) - Extend</h3>
            <div class="level3">
            
            <p>
            Implementați în fișierul <code>imageprocessing.c</code> funcția:
            </p>
            <pre class="code">int ***extend(int ***image, int N, int M, int rows, int cols, int new_R, int new_G, int new_B)</pre>
            
            <p>
            Funcția trebuie să aplice opusul operației de crop, adică să extindă imaginea cu <code>rows</code> linii atât deasupra cât și dedesubt, și cu <code>cols</code> coloane atât la stânga cât și la dreapta. Pixelii nou-creați trebuie să aibă toți aceeași culoare, dată de parametrii <code>new_R</code>, <code>new_G</code>, <code>new_B</code>.
            </p>
            
            <p>
            Exemplu. Dacă imaginea originală avea pixelii:
            $$ A = \begin{bmatrix}
            p_{11} &amp; p_{12} \\
            p_{21} &amp; p_{22} 
            \end{bmatrix} $$
            atunci, după aplicarea unui extend cu rows=1, cols=2, imaginea devine:
            $$ A = \begin{bmatrix}
            p_{n} &amp; p_{n} &amp; p_{n} &amp; p_{n} &amp; p_{n} &amp; p_{n} \\
            p_{n} &amp; p_{n} &amp; p_{11} &amp; p_{12} &amp; p_{n} &amp; p_{n} \\
            p_{n} &amp; p_{n} &amp; p_{21} &amp; p_{22} &amp; p_{n} &amp; p_{n} \\
            p_{n} &amp; p_{n} &amp; p_{n} &amp; p_{n} &amp; p_{n} &amp; p_{n}
            \end{bmatrix} $$
            unde <code>p_{n}</code> reprezintă pixeli cu valorile culorilor <code>(new_R, new_G, new_B)</code>.
            </p>
            
            </div>
            
            <h3 class="sectionedit12" id="task5_5p_-_copy_paste">Task5 (5p) - Copy Paste</h3>
            <div class="level3">
            
            <p>
            Implementați în fișierul <code>imageprocessing.c</code> funcția:
            </p>
            <pre class="code">int ***paste(int ***image_dst, int N_dst, int M_dst, int *** image_src, int N_src, int M_src, int x, int y)</pre>
            
            <p>
            Funcția trebuie să facă copy-paste de la imaginea sursă peste imaginea destinație, începând de la coordonatele (x,y) ale imaginii destinație. Dacă imaginea sursă este mai mare decât spațiul disponibil (adică ar depăși marginile imaginii destinație), atunci pixelii care depășesc trebuie ignorați. Atenție: imaginea sursă nu trebuie modificată și nici dezalocată în această funcție! Funcția trebuie să returneze pointer la imaginea destinație.
            </p>
            
            <p>
            <p><div class="noteimportant">
            Coordonata x este pe orizontală (denotă coloana) iar coordonata y este pe verticală (denotă linia).
            
            </div></p>
            </p>
            
            <p>
            Exemplu. Dacă imaginea destinație avea pixelii:
            $$ A = \begin{bmatrix}
            a_{11} &amp; a_{12} &amp; a_{13} \\
            a_{21} &amp; a_{22} &amp; a_{23} \\
            a_{31} &amp; a_{32} &amp; a_{33}
            \end{bmatrix} $$
            și imaginea sursă este:
            $$ B = \begin{bmatrix}
            b_{11} &amp; b_{12} &amp; b_{13} \\
            b_{21} &amp; b_{22} &amp; b_{23} \\
            b_{31} &amp; b_{32} &amp; b_{33}
            \end{bmatrix} $$
            atunci, după aplicarea paste la coordonatele x=1, y=1, trebuie să obținem:
            $$ A = \begin{bmatrix}
            a_{11} &amp; a_{12} &amp; a_{13} \\
            a_{21} &amp; b_{11} &amp; b_{12} \\
            a_{31} &amp; b_{21} &amp; b_{22}
            \end{bmatrix} $$
            </p>
            
            </div>
            
            <h3 class="sectionedit13" id="task6_15p_-_apply_filter">Task6 (15p) - Apply Filter</h3>
            <div class="level3">
            
            <p>
            Implementați în fișierul <code>imageprocessing.c</code> funcția:
            </p>
            <pre class="code">int ***apply_filter(int ***image, int N, int M, float **filter, int filter_size)</pre>
            
            <p>
            Funcția trebuie să modifice imaginea prin aplicarea filtrului primit ca parametru pe toți pixelii imaginii. Un filtru este o matrice bidimensională de dimensiune (filter_size x filter_size) care definește modul în care fiecare pixel este modificat în funcție de valoarea sa și de valorile vecinilor lui. În practică, filtrele sunt folosite pentru tot felul de procesări pe imagini: blur, sharpen, emboss, sobel, edge detection etc.
            </p>
            
            <p>
            De exemplu: fie $(R_{22},G_{22},B_{22})$ un pixel din imagine care are următorii vecini:
            </p>
            
            <p>
            $$ \begin{bmatrix}
            (R_{11},G_{11},B_{11}) &amp; (R_{12},G_{12},B_{12}) &amp; (R_{13},G_{13},B_{13}) \\
            (R_{21},G_{21},B_{21}) &amp; (R_{22},G_{22},B_{22}) &amp; (R_{23},G_{23},B_{23}) \\
            (R_{31},G_{31},B_{31}) &amp; (R_{32},G_{32},B_{32}) &amp; (R_{33},G_{33},B_{33})
            \end{bmatrix} $$
            </p>
            
            <p>
            și fie filtrul de dimensiune 3 (atentie - valorile din filtru sunt numere (float), nu pixeli!):
            </p>
            
            <p>
            $$ F = \begin{bmatrix}
            f_{11} &amp; f_{12} &amp; f_{13} \\
            f_{21} &amp; f_{22} &amp; f_{23} \\
            f_{31} &amp; f_{32} &amp; f_{33}
            \end{bmatrix} $$
            </p>
            
            <p>
            Atunci, în imaginea rezultată in urma aplicării filtrului <strong>A</strong>, pixelul $(R_{22},G_{22},B_{22})$ va fi înlocuit cu $(R&#039;_{22},G&#039;_{22},B&#039;_{22})$ unde:
            </p>
            
            <p>
            $$ R&#039;_{22} = \sum_{i=1}^3 \sum_{j=1}^3 R_{ij}f_{ij} $$
            $$ G&#039;_{22} = \sum_{i=1}^3 \sum_{j=1}^3 G_{ij}f_{ij} $$
            $$ B&#039;_{22} = \sum_{i=1}^3 \sum_{j=1}^3 B_{ij}f_{ij} $$
            </p>
            
            <p>
            <p><div class="noteclassic">Filtrul are valori de tip float, iar după calculul sumei, valoarea trebuie transformată în int prin rotunjire în jos (cast la int). Daca în urma calculului uneia dintre cele 3 valori de mai sus, suma rezultată este &lt; 0 atunci valoarea se va seta la 0. Asemănător, dacă suma este &gt; 255 atunci componenta corespunzatoare din pixel se va seta la 255.
            </div></p>
            </p>
            
            <p>
            <p><div class="noteimportant"><strong>Daca un pixel are vecini in afara imaginii, la calculul sumei acești vecini vor fi considerați cu valoarea (0, 0, 0).</strong>
            </div></p>
            </p>
            
            <p>
            Se garantează că filtrele primite ca parametru vor avea mereu dimensiune impară.
            </p>
            
            </div>
            
            <h3 class="sectionedit14" id="task7_30p_-_interactive_image_processor">Task7 (30p) - Interactive Image Processor</h3>
            <div class="level3">
            
            <p>
            Scrieți un program (în fișierul <code>interactive.c</code>) care execută procesări pe imagini în mod interactiv. Programul trebuie să funcționeze astfel:
            </p>
            <ul>
            <li class="level1"><div class="li"> citește de la tastatură o comandă dată de utilizator</div>
            </li>
            <li class="level1"><div class="li"> în funcție de comanda primită, citește parametrii comenzii așa cum sunt definiți mai jos</div>
            </li>
            <li class="level1"><div class="li"> aplică procesările pe imagini conform cu comanda și parametrii primiți</div>
            </li>
            <li class="level1"><div class="li"> așteaptă următoarea comandă.</div>
            </li>
            </ul>
            
            <p>
            <p><div class="noteclassic">Imaginile create cu comanda <strong>Load</strong> trebuie să primească fiecare câte un index. Astfel, prima imagine creată va avea indexul 0; a doua imagine creată va avea indexul 1; a treia imagine creată va avea indexul 2 ș.a.m.d. Indexul este folosit în comenzile de procesare de imagini pentru a selecta imaginea pe care se execută procesarea. Similar, fiecare filtru creat va primi câte un index, care va fi apoi folosit pentru selectarea filtrului de aplicat.
            </div></p>
            <p><div class="noteclassic">Prin aplicarea oricărei procesări, trebuie modificată imaginea de la indexul respectiv, nu creată o nouă imagine. Spre exemplu, dacă imaginile încărcate sunt A (poză cu cățel) și B (poză cu pisică), atunci în urma aplicării Rotate pe imaginea cu index 1, trebuie să obținem pe indexul 0 o poză cu cățel și pe indexul 1 o poză cu pisică rotită.
            </div></p>
            <p><div class="notewarning">La ștergerea unei imagini sau a unui filtru, imaginile/filtrele rămase trebuie să își schimbe indexul corespunzător. Exemplu: dacă am creat 3 imagini A,B,C (indecși 0,1,2) și 5 filtre Q,W,E,R,T (indecși 0,1,2,3,4) atunci dacă șterg imaginea 0 si filtrele 2 și 3, imaginile rămase trebuie să aibă indecși B=0, C=1, iar filtrele rămase trebuie să aibă indecși Q=0, W=1, T=2. De asemenea, <strong>la ștergerea unei imagini sau a unui filtru, matricea asociată imaginii/filtrului trebuie dezalocată</strong>
            </div></p>
            <p><div class="noteimportant">Atenție: Pentru operațiile <strong>Load</strong> (incărcarea unei imagini sub forma unei matrici NxMx3 dintr-un fișier .BMP) și <strong>Save</strong> (salvarea unei imagini date ca matrice într-un fișier .BMP) <strong>trebuie</strong> să folosiți funcțiile <code>read_from_bmp</code> și <code>write_to_bmp</code> puse la dispoziție în scheletul de cod.
            </div></p>
            </p>
            
            <p>
            Comenzile care trebuie implementate sunt următoarele:
            </p>
            <div class="table sectionedit15"><table class="inline">
                <tr class="row0">
                    <th class="col0 leftalign"> Nume comandă   </th><th class="col1 leftalign"> Parametri       </th><th class="col2 leftalign"> Descriere                    </th>
                </tr>
                <tr class="row1">
                    <td class="col0 leftalign"> e              </td><td class="col1 leftalign"> -               </td><td class="col2"> <strong>Exit</strong> - închide programul </td>
                </tr>
                <tr class="row2">
                    <td class="col0 leftalign"> l              </td><td class="col1 leftalign"> N M path        </td><td class="col2"> <strong>Load</strong> - alocă și încarcă imaginea de dimensiune NxM aflată la calea <code>path</code> </td>
                </tr>
                <tr class="row3">
                    <td class="col0 leftalign"> s              </td><td class="col1 leftalign"> index path      </td><td class="col2"> <strong>Save</strong> - salvează imaginea de pe indexul <code>index</code> la calea specificată prin <code>path</code></td>
                </tr>
                <tr class="row4">
                    <td class="col0 leftalign"> ah             </td><td class="col1 leftalign"> index           </td><td class="col2"> <strong>Apply Horizontal Flip</strong> - aplică operația de flip pe orizontală imaginii de la indexul <code>index</code></td>
                </tr>
                <tr class="row5">
                    <td class="col0 leftalign"> ar             </td><td class="col1 leftalign"> index           </td><td class="col2"> <strong>Apply Rotate</strong> - aplică operația de rotație la stânga imaginii de la indexul <code>index</code></td>
                </tr>
                <tr class="row6">
                    <td class="col0 leftalign"> ac             </td><td class="col1 leftalign"> index x y w h   </td><td class="col2"> <strong>Apply Crop</strong> - aplică operația de crop cu parametrii dați imaginii de la indexul <code>index</code></td>
                </tr>
                <tr class="row7">
                    <td class="col0 leftalign"> ae             </td><td class="col1 leftalign"> index rows cols R G B   </td><td class="col2"> <strong>Apply Extend</strong> - aplică operația de extend cu parametrii dați imaginii de la indexul <code>index</code></td>
                </tr>
                <tr class="row8">
                    <td class="col0 leftalign"> ap             </td><td class="col1"> index_dst index_src x y </td><td class="col2"> <strong>Apply Paste</strong> - aplică operația de paste cu parametrii dați imaginii de la indexul <code>index_dst</code></td>
                </tr>
                <tr class="row9">
                    <td class="col0 leftalign"> cf             </td><td class="col1 leftalign"> size [list of values]   </td><td class="col2"> <strong>Create filter</strong> - alocă și crează un filtru de dimensiune <code>size</code> cu valorile date de lista de valori (exemplu: dacă se creează un filtru de dimensiune 3, atunci după size vor urma 9 valori</td>
                </tr>
                <tr class="row10">
                    <td class="col0 leftalign"> af             </td><td class="col1 leftalign"> index_img index_filter   </td><td class="col2"> <strong>Apply filter</strong> - aplică filtrul de pe indexul <code>index_filter</code> pe imaginea de pe indexul <code>index_img</code></td>
                </tr>
                <tr class="row11">
                    <td class="col0 leftalign"> df             </td><td class="col1 leftalign"> index_filter   </td><td class="col2"> <strong>Delete filter</strong> - șterge și dezalocă filtrul de pe indexul <code>index_filter</code></td>
                </tr>
                <tr class="row12">
                    <td class="col0 leftalign"> di             </td><td class="col1 leftalign"> index_img   </td><td class="col2"> <strong>Delete image</strong> - șterge și dezalocă imaginea de pe indexul <code>index_img</code></td>
                </tr>
            </table></div>
            
            <p>
            <p><div class="noteclassic">
            Exemplu de utilizare (input al programului):
            </p>
            <pre class="code">l 768 1024 ./cat.bmp
            l 768 1024 ./dog.bmp
            ah 0
            ac 1 300 300 200 100
            cf 3 0 1 0 1 1 1 0 1 0
            af 1 0
            ap 0 1 300 300
            s 0 ./output.bmp
            df 0
            di 0
            di 0
            e</pre>
            
            <p>
            
            </div></p>
            </p>
            
            <p>
            <p><div class="noteclassic">
            Se garantează că:
            </p>
            <ul>
            <li class="level1"><div class="li"> path-urile nu vor avea lungime mai mare de 100 de caractere (puteți folosi o variabilă <code>char path[100]</code>)</div>
            </li>
            <li class="level1"><div class="li"> path-urile nu vor conține spații (pot fi citite cu <code>scanf(”%s”, path)</code>)</div>
            </li>
            <li class="level1"><div class="li"> fișierul din care se încarcă o imagine există și este valid</div>
            </li>
            <li class="level1"><div class="li"> comenzile date sunt mereu valide (nu se va da ca input o comandă inexistentă)</div>
            </li>
            <li class="level1"><div class="li"> parametrii comenzilor sunt mereu valizi (e.g. nu se va cere aplicarea unei procesări pe un index care nu există, sau paste la niște coordonate care încep în afara imaginii destinație etc)</div>
            </li>
            </ul>
            
            <p>
            
            </div></p>
            </p>
            
            <p>
            <p><div class="noteclassic">
            Atenție la următoarele lucruri:
            </p>
            <ul>
            <li class="level1"><div class="li"> imaginile nu au neaparat aceleași dimensiuni, pot avea dimensiuni diferite</div>
            </li>
            <li class="level1"><div class="li"> filtrele nu au neaparat aceeași dimensiune, pot avea dimensiuni diferite (e.g. 1, 3, 5 etc)</div>
            </li>
            <li class="level1"><div class="li"> același fișier .BMP poate fi folosit pentru <strong>Load</strong> de mai multe ori (se vor crea mai multe imagini, chiar dacă sunt identice)</div>
            </li>
            </ul>
            
            <p>
            
            </div></p>
            </p>
            
            </div>
            
            <h3 class="sectionedit16" id="task8_20p_-_clean_valgrind">Task8 (20p) - Clean Valgrind</h3>
            <div class="level3">
            
            <p>
            Pentru acest task, trebuie să aveți punctajul maxim pe taskul 7 și să nu aveți memory leaks la verificarea folosind utilitarul <a href="https://stackoverflow.com/questions/5134891/how-do-i-use-valgrind-to-find-memory-leaks" class="urlextern" title="https://stackoverflow.com/questions/5134891/how-do-i-use-valgrind-to-find-memory-leaks"  rel="nofollow">valgrind</a> pe acesta.
            </p>
            
            <p>
            Utilitarul se va rula folosind urmatoarea comanda:
            </p>
            <pre class="code"> valgrind --tool=memcheck --leak-check=full --error-exitcode=1 ./interactive </pre>
            
            </div>
            
            <h3 class="sectionedit17" id="coding_style">Coding Style</h3>
            <div class="level3">
            
            <p>
            La fel ca la tema 0, există o depunctare de până la -20p pentru coding style. Checkerul verifică coding style-ul în mod automat.
            </p>
            
            </div>
            
            <h3 class="sectionedit18" id="validare_locala_tema">Validare locală temă</h3>
            <div class="level3">
            
            <p>
            Pentru a vă ajuta în dezvoltarea temei, arhiva <a href="/courses/_media/programare/teme_2023/tema1_checker.zip" class="media mediafile mf_zip" title="programare:teme_2023:tema1_checker.zip (6.1 MB)">tema1_checker.zip</a> conține o copie a checkerului.
            </p>
            
            <p>
            Pentru a instala dependențele necesare verificării pentru <strong>coding style</strong> utilizați scriptul <strong>install-linters.sh</strong>:
            </p>
            <pre class="code">./install-linters.sh</pre>
            
            <p>
            Pentru a rula checkerul local, copiați toate fișierele checkerului în același director în care aveți codul sursă, apoi folosiți comanda:
            </p>
            <pre class="code">./check.sh</pre>
            
            <p>
            <p><div class="noteimportant">
            Checkerul trebuie rulat pe Linux! Trebuie să aveți instalat utilitarul Valgrind (care nu există pe Windows).
            
            </div></p>
            </p>
            
            </div>
            
            <h3 class="sectionedit19" id="trimitere_tema">Trimitere temă</h3>
            <div class="level3">
            
            <p>
            Tema va fi trimisă folosind Moodle, cursul <strong>Programarea Calculatoarelor (CB &amp; CD)</strong>, activitatea “Tema 1”.
            </p>
            
            <p>
            <p><div class="notewarning">
            Se va posta un anunț pe forum când se va deschide upload-ul.
            
            </div></p>
            </p>
            
            <p>
            Toate temele sunt testate în mod automat pe Moodle.
            </p>
            
            <p>
            Arhiva temei se va încărca folosind formularul de submisie (butonul <strong>Add submission</strong>.
            </p>
            
            <p>
            Rezultatele vor fi disponibile în secțiunea <strong>Feedback</strong> - nota apare la linia <strong>Grade</strong>, iar outputul checkerului și erorile apar la sectiunea <strong>Feedback comments</strong>. Dacă apare un buton albastru în formă de plus, trebuie să dați click pe el pentru a afișa întregul output al checkerului.<br/>
            
            <strong>Citiți cu atenție</strong> informațiile afișate în <strong>Feedback</strong> pentru a vă asigura că tema a fost rulată cu succes; o eroare comună este dată de faptul că conținutul arhivei nu respectă structura dorită (ex. fișierele sunt într-un alt director).<br/>
            
            </p>
            
            <p>
            <strong>Punctajul final al temei</strong> este afișat la linia <strong>Grade</strong> și la finalul outputului din checker.
            </p>
            
            <p>
            Conținutul arhivei trebuie să fie următorul:
            </p>
            <ol>
            <li class="level1"><div class="li"> Fișierele <strong>imageprocessing.c</strong>, <strong>imageprocessing.h</strong></div>
            </li>
            <li class="level1"><div class="li"> Fișierele <strong>bmp.c</strong>, <strong>bmp.h</strong></div>
            </li>
            <li class="level1"><div class="li"> Fișierul <strong>interactive.c</strong></div>
            </li>
            <li class="level1"><div class="li"> Fișierul <strong>Makefile</strong></div>
            </li>
            <li class="level1"><div class="li"> Un fișier <a href="https://en.wikipedia.org/wiki/README" class="urlextern" title="https://en.wikipedia.org/wiki/README"  rel="nofollow">README</a> în care descrieți rezolvarea temei.</div>
            </li>
            </ol>
            
            <p>
            <p><div class="notewarning">
            Arhiva trebuie să fie de tipul <strong>zip</strong>.
            
            </div></p>
            </p>
            
            <p>
            <p><div class="notewarning">
            Nu includeti fisierele checkerului in arhiva voastra.
            
            </div></p>
            </p>
            
            <p>
            <p><div class="notewarning">
            In cazul in care testele va trec local, insa pica pe vmchecker cel mai probabil aveti
            o sursa de “undefined behavior in cod”. Pentru a va asigura ca scapati de aceste probleme,
            compilati cu flagul de compilare `-Wall` si rezolvati toate warning-urile.
            
            </div></p>
            </p>
            
            </div>
            
            <h4 id="lista_depunctari">Listă depunctări</h4>
            <div class="level4">
            
            <p>
            Lista nu este exhaustivă.
            </p>
            <ul>
            <li class="level1"><div class="li"> O temă care nu compilează și nu a rulat pe <strong>vmchecker</strong> nu va fi luată în considerare</div>
            </li>
            <li class="level1"><div class="li"> O temă care nu rezolvă cerința și trece testele prin alte mijloace nu va fi luată în considerare</div>
            </li>
            <li class="level1"><div class="li"> <strong>NU acceptăm teme copiate</strong>. În cazul unei teme copiate se scade punctajul aferent temei din punctajul total. </div>
            </li>
            <li class="level1"><div class="li"> [-20.0]: Nerezolvarea tuturor erorilor și warningurilor de coding style </div>
            </li>
            </ul>
            
            </div>
            
                    </div>
    </body>
</html>